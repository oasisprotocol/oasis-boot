#!/bin/sh

# Abort on failure.
set -e

# Mount virtual filesystems.
mkdir -p /proc /sys /dev
mount none -t proc /proc
mount none -t sysfs /sys
mount none -t devtmpfs /dev
mkdir -p /dev/pts
mount none -t devpts /dev/pts

# Parse kernel commandline to extract the necessary metadata. We are using the kernel commandline
# as that is measured during boot and reflected in RTMR2. So a different configuration will result
# in a different TD identity.
stage2_root_hash=""
stage2_hash_offset=""
stage2_storage_mode=""
stage2_storage_offset=""
stage2_storage_size=""
for cfg in $(cat /proc/cmdline | xargs -n1); do
	case $cfg in
		oasis.stage2.roothash=*)
			# Stage 2 root hash.
			stage2_root_hash="${cfg//oasis.stage2.roothash=}"
		;;
		oasis.stage2.hash_offset=*)
			# Stage 2 hash offset.
			stage2_hash_offset="${cfg//oasis.stage2.hash_offset=}"
		;;
		oasis.stage2.storage_mode=*)
			# Stage 2 ephemeral storage mode.
			stage2_storage_mode="${cfg//oasis.stage2.storage_mode=}"
		;;
		oasis.stage2.storage_offset=*)
			# Stage 2 storage space offset.
			stage2_storage_offset="${cfg//oasis.stage2.storage_offset=}"
		;;
		oasis.stage2.storage_size=*)
			# Stage 2 storage space size.
			stage2_storage_size="${cfg//oasis.stage2.storage_size=}"
		;;
	esac
done

# Ensure configuration is correct.
if [[ -z "${stage2_root_hash}" || -z "${stage2_hash_offset}" ]]; then
	echo "Missing stage 2 configuration."
	exit 1
fi

# Set up dm-verity for the stage 2 root filesystem on /dev/vda.
veritysetup open \
	--hash-offset=${stage2_hash_offset} \
	--panic-on-corruption \
	/dev/vda \
	stage2 \
	/dev/vda \
	${stage2_root_hash}

# Mount stage 2 root filesystem (read-only).
mkdir -p /stage2
mount /dev/mapper/stage2 /stage2

# When stage 2 storage filesystem offset is configured, set up read-write ephemeral storage.
if [[ -n "${stage2_storage_mode}" && -d /stage2/storage ]]; then
	echo "Using ephemeral storage mode: ${stage2_storage_mode}"

	case $stage2_storage_mode in
		disk)
			if [[ -z "${stage2_storage_offset}" || -z "${stage2_storage_size}" ]]; then
				echo "Missing disk-backed stage 2 ephemeral storage configuration."
				exit 1
			fi

			# Generate a random key (this is ephemeral storage).
			storage_key=$(dd if=/dev/urandom bs=1024 count=1 2>/dev/null | tr -dc 'a-zA-Z0-9' | dd bs=1 count=64 2>/dev/null)
			# Format block device with dm-integrity and dm-crypt setup.
			echo -n "${storage_key}" | cryptsetup luksFormat \
				--offset ${stage2_storage_offset} \
				--type luks2 \
				--integrity hmac-sha256 \
				--integrity-no-wipe \
				/dev/vda
			# Open block device.
			echo -n "${storage_key}" | cryptsetup open \
				--offset ${stage2_storage_offset} \
				--type luks2 \
				/dev/vda \
				storage
			# Create and mount filesystem.
			mkfs.ext4 /dev/mapper/storage
			mount /dev/mapper/storage /stage2/storage
		;;
		ram)
			if [[ -z "${stage2_storage_size}" ]]; then
				echo "Missing ram-backed stage 2 ephemeral storage configuration."
				exit 1
			fi

			# Just use tmpfs.
			mount none -t tmpfs -o size=${stage2_storage_size} /stage2/storage
		;;
		*)
			echo "Unsupported stage 2 ephemeral storage mode."
			exit 1
		;;
	esac

	# Point /run to ephemeral storage if it exists.
	if [ -d /stage2/run ]; then
		mkdir /stage2/storage/run
		mount --bind /stage2/storage/run /stage2/run
	fi
	# Point /var to ephemeral storage if it exists.
	if [ -d /stage2/var ]; then
		mkdir /stage2/storage/var
		mkdir -p /stage2/storage/var/{lib,cache}
		mount --bind /stage2/storage/var /stage2/var
	fi
fi

# Switch into the new root.
exec switch_root /stage2 /init
